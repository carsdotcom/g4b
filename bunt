#!/usr/bin/env bash
while (( "$#" )); do shift; done

TUNDERLINE=$(tput sgr 0 1)
TRED=$(tput setaf 1)
TGREEN=$(tput setaf 2)
TYELLOW=$(tput setaf 3)
TBLUE=$(tput setaf 4)
TRESET=$(tput sgr0)
TCHECKMARK="\xe2\x9c\x93"
TXMARK="\xe2\x9c\x95"

clear
printf "\n${TUNDERLINE}${TBLUE}Running specs...${TRESET}\n" 

bunt_it_reset() {
    unset -f beforeEach
    unset -f afterEach
}

bunt_expect_reset() {
    unset bunt_given
    unset bunt_when
    unset bunt_then
    unset bunt_pass
}

describe(){
    bunt_describe_text=$1" "
}

it(){
    printf "\n  ${TYELLOW}${bunt_describe_text}${1}${TRESET}\n"
    bunt_it_reset
}

given() {
    bunt_given=$1
}

bunt_beforeEach() {
    declare -f beforeEach > /dev/null && beforeEach
}

bunt_afterEach() {
    declare -f afterEach > /dev/null && afterEach
    bunt_expect_reset
}

bunt_printPass(){
    local msg="$1"
    while (( "$#" )); do shift; done
    printf "${TGREEN}${TCHECKMARK}  "
    [ -n  "$bunt_given" ] && printf "given '${bunt_given}', "
    printf "$msg${TRESET}\n"
}

bunt_printFail(){
    local msg="$1"
    while (( "$#" )); do shift; done
    printf "${TRED}${TXMARK}  "
    [ -n  "$bunt_given" ] && printf "given '${bunt_given}', "
    printf "$msg${TRESET}\n"
}

bunt_printResult(){
    local msg="$1"
    printf "    "
    if [ $bunt_pass -eq 0 ]; then
        bunt_printFail "$msg"
    else
        bunt_printPass "$msg"
    fi
}

when() {
    local cmd
    if [ "$2 $3" == "is called" ]; then
        cmd=( $1  )
        if [ $# -gt 4 ]; then
            IFS=% cmd+=( ${@:5} )
        fi
        IFS=% bunt_when=( "${cmd[@]}" )
    fi
}

thenn() {
    local cmd
    bunt_beforeEach
    if [ "$1" == "exitWith" ]; then
        expectToExitWith $2
    elif [ "$2 $3 $4" == "should be called" ]; then
        cmd=( $1  )
        if [ $# -gt 5 ]; then
            IFS=% cmd+=( ${@:6} )
        fi
        IFS=% bunt_then=( "${cmd[@]}" )
        expectToHaveBeenCalled
    elif [ "$1 $2 $3" == "output should match" ]; then
        if [ $# -gt 3 ]; then
            expectOutputToMatch "${@:4}"
        else
            expectOutputToMatch
        fi
    elif [ "$1 $2 $3 $4" == "output should not match" ]; then
        if [ $# -gt 4 ]; then
            expectOutputNotToMatch "${@:5}"
        else
            expectOutputNotToMatch
        fi
    fi
    bunt_afterEach
    return
}

expectToExitWith() {
    local code cmd msg
    code="$1"
    while (( "$#" )); do shift; done
    IFS=% cmd=( "${bunt_when[@]}" )
    if [ ${#cmd[@]} -gt 1 ]; then
        msg="when '${cmd[0]}' is called with $(printf "'%s' " "${cmd[@]:1}"), then it should exit with $code"
    else
        msg="when '${cmd[0]}' is called, then it should exit with $code"
    fi
    "${cmd[@]}" > /dev/null 2>&1
    if [ $? -eq $code ]; then
       bunt_pass=1
    else
       bunt_pass=0
    fi
    bunt_printResult "$msg"
}

expectOutputToMatch() {
    local expected_output cmd msg cmd_output
    expected_output="$1"
    while (( "$#" )); do shift; done
    IFS=% cmd=( "${bunt_when[@]}" )
    if [ ${#cmd[@]} -gt 1 ]; then
        msg="when '${cmd[0]}' is called with$(printf " '%s'" "${cmd[@]:1}"), then output should match '$expected_output'"
    else
        msg="when '${cmd[0]}' is called, then output should match '$expected_output'"
    fi
    cmd_output=$(${cmd[@]})
    if $(echo "$cmd_output" | grep -q -e "$expected_output"); then
        bunt_pass=1
    else
        bunt_pass=0
        if [ $(echo "$cmd_output" | grep -c '$') -gt 1 ]; then
            msg+="\n       expected output to match '$expected_output'. actual was:\n\n"
            msg+=$(echo "$cmd_output" | while read line; do echo "         $line"; done)
            msg+="\n"
        else
            msg+="\n       expected output to match '$expected_output'. actual was '$cmd_output'"
        fi
    fi
    bunt_printResult "$msg"
}

expectOutputNotToMatch() {
    local expected_output cmd msg cmd_output
    expected_output="$1"
    while (( "$#" )); do shift; done
    IFS=% cmd=( "${bunt_when[@]}" )
    if [ ${#cmd[@]} -gt 1 ]; then
        msg="when '${cmd[0]}' is called with$(printf " '%s'" "${cmd[@]:1}"), then output should not match '$expected_output'"
    else
        msg="when '${cmd[0]}' is called, then output should not match '$expected_output'"
    fi
    cmd_output=$(${cmd[@]})
    if ! $(echo "$cmd_output" | grep -q -e "$expected_output"); then
        bunt_pass=1
    else
        bunt_pass=0
        if [ $(echo "$cmd_output" | grep -c '$') -gt 1 ]; then
            msg+="\n       expected output not to match '$expected_output'. actual was:\n\n"
            msg+=$(echo "$cmd_output" | while read line; do echo "         $line"; done)
            msg+="\n"
        else
            msg+="\n       expected output to not match '$expected_output'. actual was '$cmd_output'"
        fi
    fi
    bunt_printResult "$msg"
}


expectToHaveBeenCalled() {
    local subject condition subject_cmd_name condition_cmd_name msg
    while (( "$#" )); do shift; done
    IFS=% subject=( "${bunt_then[@]}" )
    IFS=% condition=( "${bunt_when[@]}" )
    subject_cmd_name="${subject[0]}"
    condition_cmd_name="${condition[0]}"
    while (( "$#" )); do shift; done
    if [ ${#subject[@]} -gt 1 ] && [ ${#condition[@]} -gt 1 ]; then
        msg="when ${condition_cmd_name} is called with$(printf " '%s'" "${condition[@]:1}"), then '${subject_cmd_name}' should be called with$(printf " '%s'" "${subject[@]:1}")"
    elif [ ${#subject[@]} -gt 1 ]; then
        msg="when ${condition_cmd_name} is called, then '${subject_cmd_name}' should be called with$(printf " '%s'" "${subject[@]:1}")"
    elif [ ${#condition[@]} -gt 1 ]; then
        msg="when ${condition_cmd_name} is called with$(printf " '%s'" "${condition[@]:1}"), then '${subject_cmd_name}' should be called"
    else
        msg="when ${condition_cmd_name} is called, then '${subject_cmd_name}' should be called"
    fi
    bunt_spy() {
        foo="$*"
        bar="${subject[*]:1}"
        if [ "$*" == "${subject[*]:1}" ]; then
            bunt_pass=1
        else
            bunt_pass=0
        fi
    }

    eval "$(echo "bunt_bkup_${subject_cmd_name}()"; declare -f ${subject_cmd_name} | tail -n +2)"
    eval "${subject_cmd_name}() { bunt_spy \"\$@\"; }"
    "${condition[@]}" > /dev/null 2>&1
    bunt_printResult "$msg"
    eval "$(echo "${subject_cmd_name}()"; declare -f bunt_bkup_${subject_cmd_name} | tail -n +2)"
}

