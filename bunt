#!/usr/bin/env bash
while (( "$#" )); do shift; done

TUNDERLINE=$(tput sgr 0 1)
TRED=$(tput setaf 1)
TGREEN=$(tput setaf 2)
TYELLOW=$(tput setaf 3)
TBLUE=$(tput setaf 4)
TRESET=$(tput sgr0)
TCHECKMARK="\xe2\x9c\x93"
TXMARK="\xe2\x9c\x95"
TLINE="\xe2\x8e\xaf"
TOTAL_COUNT=0
PASS_COUNT=0
FAIL_COUNT=0

clear
printf "\n${TUNDERLINE}${TBLUE}Running specs...${TRESET}\n" 

bunt_error() {
    local callstack=$(caller)
    local callstack_lineno=$(echo "$callstack" | awk '{print $1}')
    local callstack_file=$(echo "$callstack" | awk '{print $2}')
    local message="$1"
    local code="${2:-1}"

    printf "\n${TRED}Error on line ${callstack_lineno} of ${callstack_file}\n"
    if [[ -n "$message" ]] ; then
        printf "${TRED}Message: ${message}; exiting with status ${code}${TRESET}\n\n"
    else
        printf "${TRED}Exiting with status ${code}${TRESET}\n\n"
    fi

    exit "${code}"
}

bunt_finish() {
    local code=$?
    local msg="\n"

    [ $code -ne 0 ] && return $code

    if [ $PASS_COUNT -gt 0 ]; then
        msg+="${TGREEN}${TCHECKMARK} ${PASS_COUNT} passed"
    fi

    if [ $PASS_COUNT -gt 0 ] && [ $FAIL_COUNT -gt 0 ]; then
        msg+="${TBLUE} and "
    fi

    if [ $FAIL_COUNT -gt 0 ]; then
        msg+="${TRED}${TXMARK} ${FAIL_COUNT} failed"
    fi

    msg+="${TBLUE} of ${TBLUE}${TOTAL_COUNT} total specs${TRESET}\n\n"

    printf "$msg"

    [ $FAIL_COUNT -gt 0 ] && exit 1 || exit 0
}

setTraps() {
    local trap_func="${1:-bunt_finish}"
    local trap_err_func="${1:-bunt_error}"

    trap - 0 INT TERM
    trap $trap_func 0 INT TERM
    trap - ERR
    trap $trap_err_func ERR
}
setTraps

bunt_describe_reset() {
    unset bunt_xdescribe
}

bunt_it_reset() {
    unset -f given
    unset -f teardown
}

bunt_expect_reset() {
    unset bunt_given_text
    unset bunt_when
    unset bunt_then
    unset bunt_pass
    bunt_expected_call_count=1
    bunt_actual_call_count=0
}

label() {
    local text="$(echo $1 | tr '[:lower:]' '[:upper:]')"
    echo
    bunt_printRule
    printf "\n  $text"
    bunt_printRule
    echo
}

describe(){
    bunt_describe_reset
    bunt_describe_text=$1" "
}

xdescribe(){
    bunt_describe_text="Skipping ... $1 "
    bunt_xdescribe=true
}

it(){
    bunt_it_reset
    printf "\n  ${TYELLOW}${bunt_describe_text}${1}${TRESET}\n"
}

bunt_set_given() {
    bunt_given_text="$(declare -f given | tail -r | tail -n +2 | tail -r | tail -n +3 | while read line; do echo "   $line"; done)"
}

bunt_given() {
    declare -f given > /dev/null && bunt_set_given && given
}

bunt_teardown() {
    declare -f teardown > /dev/null && teardown
    bunt_expect_reset
}

bunt_printRule() {
    local cols

    cols=$(tput cols)
    (( cols = cols - 4 ))

    printf "\n  "
    eval printf %.0s- '{1..'"$cols"\}
}

bunt_printPass(){
    local msg="$1"

    while (( "$#" )); do shift; done

    printf "${TGREEN}${TCHECKMARK}  "
    [ -n  "$bunt_given_text" ] && printf "given \n${TBLUE}${bunt_given_text}${TRESET}\n       ${TGREEN}"
    printf "$msg${TRESET}\n"

    (( PASS_COUNT++ ))
}

bunt_printFail(){
    local frame=0
    local msg="$1"

    while (( "$#" )); do shift; done

    printf "${TRED}${TXMARK}  "
    [ -n  "$bunt_given_text" ] && printf "given \n${TBLUE}${bunt_given_text}${TRESET}\n       ${TRED}"
    msg+="\n       Call stack:"
    while $(caller $frame > /dev/null 2>&1); do
        msg+="\n         $(caller $frame)"
        ((frame++));
    done
    printf "$msg${TRESET}\n"

    (( FAIL_COUNT++ ))
}

bunt_printResult(){
    local msg="$1"

    printf "    "

    if [ "${bunt_pass:-0}" -eq 0 ]; then
        bunt_printFail "$msg"
    else
        bunt_printPass "$msg"
    fi

    (( TOTAL_COUNT++ ))
}

when() {
    local cmd

    if [ "$2 $3" == "is called" ]; then
        cmd=( $1 )
        if [ $# -gt 4 ]; then
            IFS=% cmd+=( ${@:5} )
        fi
        IFS=% bunt_when=( "${cmd[@]}" )
    fi
}

thenn() {
    local cmd
    local isNumber='^[0-9]+$'

    if [ -z "$bunt_xdescribe" ]; then
        bunt_given

        if [ "$1 $2" == "exit with" ]; then
            expectToExitWith $3

        elif [ "$2 $3 $4" == "should be called" ]; then
            cmd=( $1 )
            if [ $# -gt 5 ]; then
                if [ "$5" == "with" ]; then
                    IFS=% cmd+=( ${@:6} )
                elif [[ $5 =~ $isNumber ]] && [ "$6" == "times" ]; then
                    bunt_expected_call_count=$5
                    if [ "$7" == "with" ]; then
                        IFS=% cmd+=( ${@:8} )
                    fi
                fi
            fi
            IFS=% bunt_then=( "${cmd[@]}" )
            expectToHaveBeenCalled

        elif [ "$1 $2 $3" == "output should match" ]; then
            if [ $# -gt 3 ]; then
                expectOutputToMatch 0 "${@:4}"
            else
                expectOutputToMatch 0
            fi

        elif [ "$1 $2 $3 $4" == "output should not match" ]; then
            if [ $# -gt 4 ]; then
                expectOutputToMatch 1 "${@:5}"
            else
                expectOutputToMatch 1
            fi

        fi

        bunt_teardown
    fi
    return
}

expectToExitWith() {
    local code
    local cmd
    local msg
    local trapped
    local actual

    code="$1"
    trapped=0

    while (( "$#" )); do shift; done

    IFS=% cmd=( "${bunt_when[@]}" )

    if [ ${#cmd[@]} -gt 1 ]; then
        msg="when '${cmd[0]}' is called with $(printf "'%s' " "${cmd[@]:1}")\n       then it should exit with $code"
    else
        msg="when '${cmd[0]}' is called\n       then it should exit with $code"
    fi

    exit() {
        actual=$1
    }

    "${cmd[@]}" > /dev/null 2>&1
    actual=${actual:-$?}

    unset -f exit

    if [ -n "$BUNT_DEBUG" ]; then
        echo "expected exit code: $code"
        echo "actual exit code: $actual"
    fi

    if [ "$actual" -eq "$code" ]; then
       bunt_pass=1
    else
       bunt_pass=0
    fi

    bunt_printResult "$msg"
}

expectOutputToMatch() {
    local invert
    local invert_text
    local expected_output
    local cmd
    local msg
    local cmd_output

    invert="$1"
    expected_output="$2"

    while (( "$#" )); do shift; done

    IFS=% cmd=( "${bunt_when[@]}" )

    if [ ${#cmd[@]} -gt 1 ]; then
        msg="when '${cmd[0]}' is called with$(printf " '%s'" "${cmd[@]:1}")\n       then output should match '$expected_output'"
    else
        msg="when '${cmd[0]}' is called\n       then output should match '$expected_output'"
    fi

    cmd_output=$(${cmd[@]})

    if $(echo "$cmd_output" | grep -q -e "$expected_output"); then
        bunt_pass=1
    else
        bunt_pass=0
    fi

    if [ "$invert" -eq 1 ]; then
        if [ "$bunt_pass" -eq 0 ]; then
            bunt_pass=1
        else
            bunt_pass=0
        fi
        invert_text=" not"
    fi

    if [ "$bunt_pass" -eq 0 ]; then
        if [ $(echo "$cmd_output" | grep -c '$') -gt 1 ]; then
            msg+="\n       expected output to${invert_text} match '$expected_output'. actual was:\n\n"
            msg+=$(echo "$cmd_output" | while read line; do echo "         $line"; done)
            msg+="\n"
        else
            msg+="\n       expected output${invert_text} to match '$expected_output'. actual was '$cmd_output'"
        fi
    fi

    bunt_printResult "$msg"
}

expectToHaveBeenCalled() {
    local subject
    local expected_args
    local condition
    local subject_cmd_name
    local subject_output
    local subject_code
    local subject_is_func
    local condition_cmd_name
    local msg
    local bunt_pass_tmp
    local spy_dir
    local condition_script_name
    local condition_script
    local actual_args

    while (( "$#" )); do shift; done

    IFS=% subject=( "${bunt_then[@]}" )
    expected_args="${bunt_then[*]:1}"
    subject_cmd_name="${subject[0]}"

    IFS=% condition=( "${bunt_when[@]}" )
    condition_cmd_name="${condition[0]}"

    while (( "$#" )); do shift; done

    msg="when ${condition_cmd_name} is called"

    if [ ${#condition[@]} -gt 1 ]; then
        msg+=" with$(printf " '%s'" "${condition[@]:1}")"
    fi

    msg+="\n       then '${subject_cmd_name}' should be called"

    if [ ${#subject[@]} -gt 1 ]; then
        msg+=" with$(printf " '%s'" "${subject[@]:1}")"
    fi

    msg+=" ${bunt_expected_call_count} times"

    # capture original subject output and code for later use
    subject_output=$("${subject[@]}" 2>&1)
    subject_code=$?

    # if subject is function back up the original before we replace with spy
    if [ "$(type -t "${subject_cmd_name}")" == function ]; then
        subject_is_func=1
        eval "$(echo "bunt_bkup_${subject_cmd_name}()" && declare -f "${subject_cmd_name}" | tail -n +2)"
        unset -f "${subject_cmd_name}"
    fi

    # make temp file within which to store bunt_pass value
    bunt_args_tmp=$(mktemp -t tmp)
    bunt_calls_tmp=$(mktemp -t tmp)

    # make temp directory within which to write spy as script
    spy_dir="$(mktemp -t tmp -d)"

    # write spy as script to temp directory ... spy writes bunt_pass value to above tmp file
    if [ -n "${subject[*]:1}" ]; then
        # define spy for the "called with" case...
        echo "call_count=\$(cat \"$bunt_calls_tmp\" 2>/dev/null || echo 0);\
            (( call_count++ ));\
            echo \$call_count >| \"$bunt_calls_tmp\";\
            IFS=% args=( "\$@" );\
            echo \"\${args[*]}\" >| \"$bunt_args_tmp\";\
            [ -n \"$subject_output\" ] && printf \"${subject_output}\" && return \"${subject_code}\"" > "${spy_dir}/${subject_cmd_name}"
    else
        # define spy for the "called" case
        echo "call_count=\$(cat \"$bunt_calls_tmp\" 2>/dev/null || echo 0);\
            (( call_count++ ));\
            echo \$call_count >| \"$bunt_calls_tmp\";\
            [ -n \"$subject_output\" ] && printf \"$subject_output\" && return \"${subject_code}\"" > "${spy_dir}/${subject_cmd_name}"
    fi

    # make spy script executable
    chmod +x "${spy_dir}/${subject_cmd_name}"

    # backup PATH
    PATH_BKUP="$PATH"
    # add temp directory to beginning of PATH
    PATH="$spy_dir:$PATH"

    # make temp file to hold condition as a script
    condition_script_name="$(mktemp -t tmp)"
    # write condition function as script to temp file
    echo "$(declare -f ${condition_cmd_name} | tail -r | tail -n +2 | tail -r | tail -n +3)" > "$condition_script_name"
    # build condition to source conditional condition so it will run in same context as above set PATH
    IFS=% condition_script=( "source" "$condition_script_name" "${condition[@]:1}" )

    # run above condition which will source condition script with arguments
    if [ -n "$BUNT_DEBUG" ]; then
        "${condition_script[@]}"
    else
        "${condition_script[@]}" > /dev/null 2>&1
    fi

    if [ -n "$subject_is_func" ]; then
        # restore
        eval "$(echo "${subject_cmd_name}()" && declare -f "bunt_bkup_${subject_cmd_name}" | tail -n +2)"
    fi

    # DEBUG
    if [ -n "$BUNT_DEBUG" ]; then
        echo "subject script: ${spy_dir}/${subject_cmd_name}"
        echo "condition script: ${condition_script[@]}"
    fi

    # read actual call count from temp file
    bunt_actual_call_count="$(cat "$bunt_calls_tmp")"

    if [ "$bunt_expected_call_count" -eq "$bunt_actual_call_count" ]; then
        bunt_pass=1
    else
        msg+="\n       expected ${bunt_expected_call_count} calls but saw ${bunt_actual_call_count}"
        bunt_pass=0
    fi

    # if arguments were expected...
    if [ -n "${subject[*]:1}" ]; then

        # read actual args from temp file
        IFS=% actual_args="$(cat "$bunt_args_tmp")"
        actual_args="${actual_args[*]}"

        if [ -n "$BUNT_DEBUG" ]; then
            echo "actual args: $actual_args"
            echo "expected args: $expected_args"
        fi

        if [ "$actual_args" == "$expected_args" ]; then
            bunt_pass=1
        else
            bunt_pass=0
        fi
    fi

    # print result
    bunt_printResult "$msg"

    # restore PATH
    export PATH="$PATH_BKUP"
}

